{
  "name": "vecmath",
  "version": "0.0.3",
  "description": "Highly optimized vector/matrix math (using objects)",
  "main": "lib/index.js",
  "scripts": {
    "test": "node test.js"
  },
  "author": "",
  "license": "BSD-2-Clause",
  "repository": {
    "type": "git",
    "url": "https://github.com/mattdesl/vecmath"
  },
  "dependencies": {},
  "devDependencies": {
    "browserify": "~3.3.0",
    "uglify-js": "~2.4.7"
  },
  "readme": "## vecmath\n\nThis is a small vector module, built with the optimized codebase of [gl-matrix](https://github.com/toji/gl-matrix) but using objects and JavaScript paradigms instead of typed arrays. \n\n## install\n\nWith node:\n\n```\nnpm install vecmath\n\n... in code ...\nvar Matrix4 = require('vecmath').Matrix4;\n```\n\nOr you can grab the UMD build from the `build` folder, which will work with RequireJS or a non-module app.\n\n## Why another library?\n\ngl-matrix is indeed one of the best and fastest vector/matrix libraries for real-time JavaScript, especially for WebGL purposes (thanks to its use of typed arrays). However, it leads to a poor end-user experience, for example if you are buidling a 2D or 3D game framework on top of gl-matrix. The end-user code looks like this:\n\n```javascript\nvar test = vec3.create();\nvar other = vec3.fromValues(5, 2, 1);\nvar other2 = vec3.copy( vec3.create(), other );\n\nvar x = sprite.position[0] + otherSprite.position[0];\nvec3.normalize( sprite.velocity, sprite.velocity );\nvec3.scale( sprite.velocity, sprite.velocity, 5 );\n\nfoobar( sprite.velocity[0], sprite.velocity[1], sprite.velocity[2] );\n\n.. etc ..\n```\n\nUsing array indices is error-prone, has no auto-completion or IDE refactoring, and makes your code more difficult to read. The static method calls also tend to bloat your math code. It just doesn't feel \"right\" with a language as dynamic as JavaScript. \n\n\nInstead, with this module, the above code can be written like so:\n\n```javascript\nvar test = new Vector3();\nvar other = new Vector3(5, 2, 1);\nvar other2 = new Vector3(other);\n\nvar x = sprite.position.x + otherSprite.position.x;\n\nsprite.velocity.normalize().scale(5);\n\nfoobar( sprite.x, sprite.y, sprite.z );\n```\n\nIt adds features like method chaining, optional parameters to constructor, and XYZW access for clean end-user code. \n\n## What about performance?\n\nThe reason gl-matrix is so blazingly fast is mostly because its code is highly optimized. It unrolls loops, uses inline code everywhere, and takes advantage of JS variable caching. \n\nThanks to optimizations on JS engines (V8, SpiderMonkey, etc), hidden classes and inline caches are _really_ fast nowadays (and will probably only get faster). As you can see in the following benchmarks, class-based Vectors actually outperform array access:\n \nhttp://jsperf.com/gl-matrix-vs-objects/4  \nhttp://jsperf.com/gl-matrix-vs-vecmath\n\nIt's important to realize that the difference between property and array accessors is negligible for the vast majority of applications, so you shouldn't be sacrificing code readability and maintainability for a change that won't make a dent in the long run.\n\n## What about WebGL?\n\nUsing a typed array (if available) for matrices was definitely the right choice of gl-matrix, and so we do the same for WebGL compatibility. Matrix objects have `val`, which is the backing array (Float32Array, or falls back to Array for old browsers).\n\n```javascript\nvar mat = new Matrix4();\n\ngl.uniformMatrix4fv(loc, false, mat.val);\n```\n\n## What about new objects?\n\nJust like in gl-matrix, the API tries to encourage re-using vectors to avoid allocations. So often your code will look like this:\n\n```javascript\nmyVec.add( tmp.set(0, 10, 50) );\n```\n\nHowever, if you need to create new objects (out of laziness or some other reason), all functions that take a vector/quaternion type will support lightweight objects as well:\n\n```javascript\nmyVec.add({ x:0, y: 10, z: 50 });\n```\n\nThese are usually a lot faster to allocate than a Vector class, or a Float32Array (in the case of gl-matrix). \n\nIf you find yourself creating a lot of objects, you should use a Pool to reduce allocations. \n\n## Extra features\n\nThe library does its best to stay consistent with the gl-matrix API, but also includes a couple extra features:\n\n- `Vector3.project(projMatrix)`: this method is useful for projecting a 3D point into 2D space\n- `Vector3.unproject(viewport, invProjMatrix)`: useful for _un_projecting a 2D point into 3D space\n\n## TODO:\n\n- Move docs over from gl-matrix\n- Add licensing information since most of the code belongs to gl-matrix (???)\n- Add mat2 and mat2d\n- Test Quaternion + Matrix classes and compare with gl-matrix results\n- Further improvements to test suite, using mocha or something\n- Standalone UMD build for non-node users",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/mattdesl/vecmath/issues"
  },
  "_id": "vecmath@0.0.3",
  "_from": "vecmath@"
}
